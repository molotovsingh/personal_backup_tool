{% extends "base.html" %}

{% block title %}Dashboard - Backup Manager{% endblock %}

{% block content %}
<div class="max-w-7xl">
    <h1 class="text-3xl font-bold mb-6">Dashboard</h1>

    <!-- Stats Cards with Auto-refresh -->
    <div id="dashboard-stats"
         hx-get="/stats"
         hx-trigger="every 5s"
         hx-swap="outerHTML">
        {% include 'partials/dashboard_stats.html' %}
    </div>

    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <!-- Active Jobs Panel with Auto-refresh -->
        <div id="active-jobs"
             hx-get="/active-jobs"
             hx-trigger="every 3s"
             hx-swap="outerHTML">
            {% include 'partials/dashboard_active_jobs.html' %}
        </div>

        <!-- Recent Activity Panel -->
        <div id="recent-activity"
             hx-get="/recent-activity"
             hx-trigger="every 10s"
             hx-swap="outerHTML">
            {% include 'partials/dashboard_recent_activity.html' %}
        </div>
    </div>

    <!-- Quick Actions -->
    <div class="mt-8 grid grid-cols-1 md:grid-cols-3 gap-4">
        <a href="/jobs" class="bg-blue-600 text-white p-6 rounded-lg shadow hover:bg-blue-700 transition text-center">
            <div class="text-3xl mb-2">üìã</div>
            <h3 class="font-bold text-lg">Manage Jobs</h3>
            <p class="text-sm text-blue-100 mt-1">Create, start, and monitor backups</p>
        </a>

        <a href="/logs" class="bg-green-600 text-white p-6 rounded-lg shadow hover:bg-green-700 transition text-center">
            <div class="text-3xl mb-2">üìù</div>
            <h3 class="font-bold text-lg">View Logs</h3>
            <p class="text-sm text-green-100 mt-1">Check backup logs and activity</p>
        </a>

        <a href="/settings" class="bg-purple-600 text-white p-6 rounded-lg shadow hover:bg-purple-700 transition text-center">
            <div class="text-3xl mb-2">‚öôÔ∏è</div>
            <h3 class="font-bold text-lg">Settings</h3>
            <p class="text-sm text-purple-100 mt-1">Configure backup preferences</p>
        </a>
    </div>
</div>

<!-- WebSocket for Real-time Updates -->
<script>
    // WebSocket reconnection state
    let ws = null;
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 10;
    const BASE_RECONNECT_DELAY = 1000; // 1 second
    const MAX_RECONNECT_DELAY = 30000; // 30 seconds
    let reconnectTimeout = null;
    let pollingFallback = null;

    // Connection status indicator
    function updateConnectionStatus(status, message) {
        let statusEl = document.getElementById('ws-connection-status');
        if (!statusEl) {
            statusEl = document.createElement('div');
            statusEl.id = 'ws-connection-status';
            statusEl.className = 'fixed top-4 right-4 px-4 py-2 rounded-lg shadow-lg text-sm font-medium z-50';
            document.body.appendChild(statusEl);
        }

        if (status === 'connected') {
            statusEl.className = 'fixed top-4 right-4 px-4 py-2 rounded-lg shadow-lg text-sm font-medium z-50 bg-green-100 text-green-800 border border-green-300';
            statusEl.textContent = '‚óè Connected';
            setTimeout(() => statusEl.style.display = 'none', 3000);
        } else if (status === 'reconnecting') {
            statusEl.className = 'fixed top-4 right-4 px-4 py-2 rounded-lg shadow-lg text-sm font-medium z-50 bg-yellow-100 text-yellow-800 border border-yellow-300';
            statusEl.textContent = `‚óè Reconnecting... (${message})`;
            statusEl.style.display = 'block';
        } else if (status === 'disconnected') {
            statusEl.className = 'fixed top-4 right-4 px-4 py-2 rounded-lg shadow-lg text-sm font-medium z-50 bg-red-100 text-red-800 border border-red-300';
            statusEl.textContent = '‚óè Disconnected - ' + message;
            statusEl.style.display = 'block';
        }
    }

    // Show notification toast
    function showNotification(level, message, details) {
        const notificationContainer = document.getElementById('notification-container') || createNotificationContainer();

        const notification = document.createElement('div');
        notification.className = 'notification transform transition-all duration-300 ease-in-out mb-3 p-4 rounded-lg shadow-lg max-w-md';

        // Style based on level
        const levelStyles = {
            'info': 'bg-blue-100 text-blue-800 border border-blue-300',
            'success': 'bg-green-100 text-green-800 border border-green-300',
            'warning': 'bg-yellow-100 text-yellow-800 border border-yellow-300',
            'error': 'bg-red-100 text-red-800 border border-red-300'
        };
        notification.className += ' ' + (levelStyles[level] || levelStyles['info']);

        // Build notification HTML
        let html = '<div class="flex items-start">';
        html += '<div class="flex-1">';
        html += `<div class="font-semibold">${escapeHtml(message)}</div>`;
        if (details) {
            html += `<div class="text-sm mt-1 opacity-90">${escapeHtml(details)}</div>`;
        }
        html += '</div>';
        html += '<button class="ml-4 text-gray-500 hover:text-gray-700" onclick="this.parentElement.parentElement.remove()">‚úï</button>';
        html += '</div>';

        notification.innerHTML = html;
        notificationContainer.appendChild(notification);

        // Auto-dismiss after 7 seconds
        setTimeout(() => {
            notification.style.opacity = '0';
            setTimeout(() => notification.remove(), 300);
        }, 7000);
    }

    function createNotificationContainer() {
        const container = document.createElement('div');
        container.id = 'notification-container';
        container.className = 'fixed top-20 right-4 z-50';
        document.body.appendChild(container);
        return container;
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Connect to WebSocket with reconnection logic
    function connectWebSocket() {
        // Clear any pending reconnection timeout
        if (reconnectTimeout) {
            clearTimeout(reconnectTimeout);
            reconnectTimeout = null;
        }

        try {
            // Use the same port as the current page (works for both development and production)
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = wsProtocol + '//' + window.location.host + '/ws';
            ws = new WebSocket(wsUrl);

            ws.onopen = function() {
                console.log('Dashboard: WebSocket connected');
                reconnectAttempts = 0; // Reset retry counter on successful connection
                updateConnectionStatus('connected', '');
            };

            ws.onmessage = function(event) {
                const message = JSON.parse(event.data);
                console.log('Dashboard: Message received', message);

                // Handle job_update and job_final_update message types
                if (message.type === 'job_update' || message.type === 'job_final_update') {
                    const data = message;

                    // Update active job if it's displayed
                    const jobDiv = document.querySelector(`[data-job-id="${data.job_id}"]`);
                    if (jobDiv) {
                        // Update progress bar
                        const progressBar = jobDiv.querySelector('.progress-bar');
                        if (progressBar && data.percent !== undefined) {
                            progressBar.style.width = data.percent + '%';
                        }

                        // Update percentage text
                        const percentText = jobDiv.querySelector('.text-blue-600');
                        if (percentText && data.percent !== undefined) {
                            percentText.textContent = data.percent + '%';
                        }

                        // Update speed
                        const speedInfo = jobDiv.querySelector('.speed-info');
                        if (speedInfo && data.speed_bytes !== undefined) {
                            speedInfo.textContent = (data.speed_bytes / 1024).toFixed(2) + ' KB/s';
                        }

                        // Update transfer info
                        const transferInfo = jobDiv.querySelector('.transfer-info');
                        if (transferInfo && data.bytes_transferred !== undefined) {
                            const transferredMB = (data.bytes_transferred / 1048576).toFixed(2);
                            const totalMB = (data.total_bytes / 1048576).toFixed(2);
                            transferInfo.textContent = `Transferred: ${transferredMB} / ${totalMB} MB`;
                        }

                        // Update ETA
                        const etaInfo = jobDiv.querySelector('.eta-info');
                        if (etaInfo && data.eta_seconds !== undefined) {
                            if (data.eta_seconds > 0) {
                                const etaMin = (data.eta_seconds / 60).toFixed(1);
                                etaInfo.textContent = `ETA: ${etaMin} min`;
                            } else {
                                etaInfo.textContent = 'ETA: calculating...';
                            }
                        }

                        // Handle final state - trigger HTMX refresh instead of page reload
                        if (message.type === 'job_final_update') {
                            console.log('Dashboard: Job reached final state', data.status);
                            // Use HTMX to refresh dashboard panels (smooth, no full page reload)
                            setTimeout(() => {
                                const statsPanel = document.getElementById('dashboard-stats');
                                const activePanel = document.getElementById('active-jobs');
                                const activityPanel = document.getElementById('recent-activity');

                                if (statsPanel) {
                                    htmx.ajax('GET', '/stats', {
                                        target: '#dashboard-stats',
                                        swap: 'outerHTML'
                                    });
                                }
                                if (activePanel) {
                                    htmx.ajax('GET', '/active-jobs', {
                                        target: '#active-jobs',
                                        swap: 'outerHTML'
                                    });
                                }
                                if (activityPanel) {
                                    htmx.ajax('GET', '/recent-activity', {
                                        target: '#recent-activity',
                                        swap: 'outerHTML'
                                    });
                                }
                            }, 1000);
                        }
                    }
                }

                // Handle notification messages
                if (message.type === 'notification') {
                    showNotification(message.level, message.message, message.details);
                }
            };

            ws.onerror = function(error) {
                console.error('Dashboard: WebSocket error', error);
            };

            ws.onclose = function() {
                console.log('Dashboard: WebSocket disconnected');

                // Check if we've exceeded max retry attempts
                if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                    console.log('Dashboard: Max reconnection attempts reached');
                    updateConnectionStatus('disconnected', 'Refresh to reconnect');
                    return;
                }

                // Calculate exponential backoff delay with jitter
                const exponentialDelay = Math.min(
                    BASE_RECONNECT_DELAY * Math.pow(2, reconnectAttempts),
                    MAX_RECONNECT_DELAY
                );
                const jitter = Math.random() * 1000; // Add 0-1s random jitter
                const delay = Math.floor(exponentialDelay + jitter);

                reconnectAttempts++;
                console.log(`Dashboard: Reconnecting in ${delay}ms (attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);
                updateConnectionStatus('reconnecting', `attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS}`);

                // Schedule reconnection
                reconnectTimeout = setTimeout(() => connectWebSocket(), delay);
            };

        } catch (error) {
            console.error('Dashboard: Failed to create WebSocket', error);
            // Retry with exponential backoff
            if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                const delay = Math.min(
                    BASE_RECONNECT_DELAY * Math.pow(2, reconnectAttempts),
                    MAX_RECONNECT_DELAY
                );
                reconnectAttempts++;
                reconnectTimeout = setTimeout(() => connectWebSocket(), delay);
            }
        }
    }

    // Initial connection
    connectWebSocket();
</script>
{% endblock %}
